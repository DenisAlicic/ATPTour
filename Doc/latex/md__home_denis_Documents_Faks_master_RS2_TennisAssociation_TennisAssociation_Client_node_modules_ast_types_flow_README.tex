Flow types for the Javascript AST. Based off of \href{https://github.com/benjamn/ast-types}{\texttt{ benjamn/ast-\/types}}.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_ast_types_flow_README_autotoc_md19782}{}\doxysection{Usage}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_ast_types_flow_README_autotoc_md19782}
First install {\ttfamily ast-\/types-\/flow} via npm, then you can import any of the types that are exported.


\begin{DoxyCode}{0}
\DoxyCodeLine{/* @flow */}
\DoxyCodeLine{}
\DoxyCodeLine{import type \{Node\} from 'ast-\/types-\/flow';}
\DoxyCodeLine{}
\DoxyCodeLine{function getName(node: Node): string \{}
\DoxyCodeLine{  switch (node.type) \{}
\DoxyCodeLine{    case 'Identifier':}
\DoxyCodeLine{      return node.name;}
\DoxyCodeLine{}
\DoxyCodeLine{    case 'ClassDeclaration':}
\DoxyCodeLine{      return node.id.name; // Error, id could be null.}
\DoxyCodeLine{}
\DoxyCodeLine{    case 'FunctionDeclaration':}
\DoxyCodeLine{      return node.id.name; // Fine if it's always there.}
\DoxyCodeLine{}
\DoxyCodeLine{    case 'FunctionExpression':}
\DoxyCodeLine{      if (node.id) \{}
\DoxyCodeLine{        return node.id.name; // Can refine id to make sure it exists.}
\DoxyCodeLine{      \} else \{}
\DoxyCodeLine{        return 'Unknown';}
\DoxyCodeLine{      \}}
\DoxyCodeLine{}
\DoxyCodeLine{    case 'Literal':}
\DoxyCodeLine{      return node.name; // Error, Literals don't have names, don't be silly.}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  return 'Unknown';}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_ast_types_flow_README_autotoc_md19783}{}\doxysection{How it works}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_ast_types_flow_README_autotoc_md19783}
A notion of \char`\"{}extends\char`\"{} is added to the Flow syntax via comments. A transform is included that will compile the source code into useful disjoint union types based on how the different types extend each other. For example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type Node = \{}
\DoxyCodeLine{  common: string,}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{type Foo = \{}
\DoxyCodeLine{  // extends Node}
\DoxyCodeLine{  foo: string,}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{type Bar = \{}
\DoxyCodeLine{  // extends Node}
\DoxyCodeLine{  bar: number,}
\DoxyCodeLine{\};}

\end{DoxyCode}


Will be transformed into\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{type Node = \{}
\DoxyCodeLine{  type: 'Foo',}
\DoxyCodeLine{  \_Foo: void,}
\DoxyCodeLine{  common: string,}
\DoxyCodeLine{  foo: string,}
\DoxyCodeLine{\} | \{}
\DoxyCodeLine{  type: 'Bar',}
\DoxyCodeLine{  \_Bar: void,}
\DoxyCodeLine{  common: string,}
\DoxyCodeLine{  bar: number,}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{type Foo = \{}
\DoxyCodeLine{  type: 'Foo',}
\DoxyCodeLine{  \_Foo: void,}
\DoxyCodeLine{  common: string,}
\DoxyCodeLine{  foo: string,}
\DoxyCodeLine{\};}
\DoxyCodeLine{}
\DoxyCodeLine{type Bar = \{}
\DoxyCodeLine{  type: 'Bar',}
\DoxyCodeLine{  \_Foo: void,}
\DoxyCodeLine{  common: string,}
\DoxyCodeLine{  bar: number,}
\DoxyCodeLine{\};}

\end{DoxyCode}


A few things to note\+:


\begin{DoxyEnumerate}
\item The type {\ttfamily Node} would more ideally be compiled into {\ttfamily Foo $\vert$ Bar} but then the disjoint union cannot be properly refined. For now we have to duplicate the complete definitions.
\item Each entry in a disjoint union has to be structurally unique or Flow will have an error on the definition. That is why the private {\ttfamily \+\_\+\+Foo\+: void} fields appear in the types. 
\end{DoxyEnumerate}