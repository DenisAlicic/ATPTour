A promise based, dynamic priority queue runner, with concurrency limiting.


\begin{DoxyCode}{0}
\DoxyCodeLine{const RunQueue = require('run-\/queue')}
\DoxyCodeLine{}
\DoxyCodeLine{const queue = new RunQueue(\{}
\DoxyCodeLine{  maxConcurrency: 1}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{queue.add(1, example, [-\/1])}
\DoxyCodeLine{for (let ii = 0; ii < 5; ++ii) \{}
\DoxyCodeLine{  queue.add(0, example, [ii])}
\DoxyCodeLine{\}}
\DoxyCodeLine{const finished = []}
\DoxyCodeLine{queue.run().then(}
\DoxyCodeLine{  console.log(finished)}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{function example (num, next) \{}
\DoxyCodeLine{  setTimeout(() => \{}
\DoxyCodeLine{    finished.push(num)}
\DoxyCodeLine{    next()}
\DoxyCodeLine{  \}, 5 -\/ Math.abs(num))}
\DoxyCodeLine{\}}

\end{DoxyCode}


would output


\begin{DoxyCode}{0}
\DoxyCodeLine{[ 0, 1, 2, 3, 4, -\/1 ]}

\end{DoxyCode}


If you bump concurrency to {\ttfamily 2}, then you get\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[ 1, 0, 3, 2, 4, -\/1 ]}

\end{DoxyCode}


The concurrency means that they don\textquotesingle{}t finish in order, because some take longer than others. Each priority level must finish entirely before the next priority level is run. See \href{https://github.com/iarna/run-queue\#priorities}{\texttt{ PRIORITIES}} below. This is even true if concurrency is set high enough that all of the regular queue can execute at once, for instance, with {\ttfamily max\+Concurrency\+: 10}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{[ 4, 3, 2, 1, 0, -\/1 ]}

\end{DoxyCode}
\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24085}{}\doxysection{API}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24085}
\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24086}{}\doxysubsection{const queue = new Run\+Queue(options)}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24086}
Create a new queue. Options may contain\+:


\begin{DoxyItemize}
\item max\+Concurrency -\/ (Default\+: {\ttfamily 1}) The maximum number of jobs to execute at once.
\item Promise -\/ (Default\+: global.\+Promise) The promise implementation to use.
\end{DoxyItemize}\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24087}{}\doxysubsection{queue.\+add (prio, fn, args)}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24087}
Add a new job to the end of the queue at priority {\ttfamily prio} that will run {\ttfamily fn} with {\ttfamily args}. If {\ttfamily fn} is async then it should return a Promise.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24088}{}\doxysubsection{queue.\+run ()}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24088}
Start running the job queue. Returns a Promise that resolves when either all the jobs are complete or a job ends in error (throws or returns a rejected promise). If a job ended in error then this Promise will be rejected with that error and no further queue running will be done.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24089}{}\doxysection{PRIORITIES}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules_run_queue_README_autotoc_md24089}
Priorities are any integer value $>$= 0.

Lowest is executed first.

Priorities essentially represent distinct job queues. All jobs in a queue must complete before the next highest priority job queue is executed.

This means that if you have two queues, {\ttfamily 0} and {\ttfamily 1} then ALL jobs in {\ttfamily 0} must complete before ANY execute in {\ttfamily 1}. If you add new {\ttfamily 0} level jobs while {\ttfamily 1} level jobs are running then it will switch back processing the {\ttfamily 0} queue and won\textquotesingle{}t execute any more {\ttfamily 1} jobs till all of the new {\ttfamily 0} jobs complete. 