A prompting wizard for building files from specialized Prom\+Zard modules. Used by {\ttfamily npm init}.

A reimplementation of @\+Sub\+Stack\textquotesingle{}s \href{https://github.com/substack/node-prompter}{\texttt{ prompter}}, which does not use AST traversal.

From another point of view, it\textquotesingle{}s a reimplementation of \href{https://github.com/marak}{\texttt{ @\+Marak}}\textquotesingle{}s \href{https://github.com/Marak/wizard}{\texttt{ wizard}} which doesn\textquotesingle{}t use schemas.

The goal is a nice drop-\/in enhancement for {\ttfamily npm init}.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15143}{}\doxysection{Usage}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15143}

\begin{DoxyCode}{0}
\DoxyCodeLine{var promzard = require('promzard')}
\DoxyCodeLine{promzard(inputFile, optionalContextAdditions, function (er, data) \{}
\DoxyCodeLine{  // .. you know what you doing ..}
\DoxyCodeLine{\})}

\end{DoxyCode}


In the {\ttfamily input\+File} you can have something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var fs = require('fs')}
\DoxyCodeLine{module.exports = \{}
\DoxyCodeLine{  "{}greeting"{}: prompt("{}Who shall you greet?"{}, "{}world"{}, function (who) \{}
\DoxyCodeLine{    return "{}Hello, "{} + who}
\DoxyCodeLine{  \}),}
\DoxyCodeLine{  "{}filename"{}: \_\_filename,}
\DoxyCodeLine{  "{}directory"{}: function (cb) \{}
\DoxyCodeLine{    fs.readdir(\_\_dirname, cb)}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\}}

\end{DoxyCode}


When run, promzard will display the prompts and resolve the async functions in order, and then either give you an error, or the resolved data, ready to be dropped into a JSON file or some other place.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15144}{}\doxysubsection{promzard(input\+File, ctx, callback)}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15144}
The input\+File is just a node module. You can require() things, set module.\+exports, etc. Whatever that module exports is the result, and it is walked over to call any functions as described below.

The only caveat is that you must give Prom\+Zard the full absolute path to the module (you can get this via Node\textquotesingle{}s {\ttfamily require.\+resolve}.) Also, the {\ttfamily prompt} function is injected into the context object, so watch out.

Whatever you put in that {\ttfamily ctx} will of course also be available in the module. You can get quite fancy with this, passing in existing configs and so on.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15145}{}\doxysubsection{Class\+: promzard.\+Prom\+Zard(file, ctx)}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15145}
Just like the {\ttfamily promzard} function, but the Event\+Emitter that makes it all happen. Emits either a {\ttfamily data} event with the data, or a {\ttfamily error} event if it blows up.

If {\ttfamily error} is emitted, then {\ttfamily data} never will be.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15146}{}\doxysubsection{prompt(...)}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15146}
In the promzard input module, you can call the {\ttfamily prompt} function. This prompts the user to input some data. The arguments are interpreted based on type\+:


\begin{DoxyEnumerate}
\item {\ttfamily string} The first string encountered is the prompt. The second is the default value.
\item {\ttfamily function} A transformer function which receives the data and returns something else. More than meets the eye.
\item {\ttfamily object} The {\ttfamily prompt} member is the prompt, the {\ttfamily default} member is the default value, and the {\ttfamily transform} is the transformer.
\end{DoxyEnumerate}

Whatever the final value is, that\textquotesingle{}s what will be put on the resulting object.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15147}{}\doxysubsection{Functions}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15147}
If there are any functions on the promzard input module\textquotesingle{}s exports, then promzard will call each of them with a callback. This way, your module can do asynchronous actions if necessary to validate or ascertain whatever needs verification.

The functions are called in the context of the ctx object, and are given a single argument, which is a callback that should be called with either an error, or the result to assign to that spot.

In the async function, you can also call prompt() and return the result of the prompt in the callback.

For example, this works fine in a promzard module\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{exports.asyncPrompt = function (cb) \{}
\DoxyCodeLine{  fs.stat(someFile, function (er, st) \{}
\DoxyCodeLine{    // if there's an error, no prompt, just error}
\DoxyCodeLine{    // otherwise prompt and use the actual file size as the default}
\DoxyCodeLine{    cb(er, prompt('file size', st.size))}
\DoxyCodeLine{  \})}
\DoxyCodeLine{\}}

\end{DoxyCode}


You can also return other async functions in the async function callback. Though that\textquotesingle{}s a bit silly, it could be a handy way to reuse functionality in some cases.\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15148}{}\doxysubsection{Sync vs Async}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15148}
The {\ttfamily prompt()} function is not synchronous, though it appears that way. It just returns a token that is swapped out when the data object is walked over asynchronously later, and returns a token.

For that reason, prompt() calls whose results don\textquotesingle{}t end up on the data object are never shown to the user. For example, this will only prompt once\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{exports.promptThreeTimes = prompt('prompt me once', 'shame on you')}
\DoxyCodeLine{exports.promptThreeTimes = prompt('prompt me twice', 'um....')}
\DoxyCodeLine{exports.promptThreeTimes = prompt('you cant prompt me again')}

\end{DoxyCode}
\hypertarget{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15149}{}\doxysubsection{Isn\textquotesingle{}t this exactly the sort of \textquotesingle{}looks sync\textquotesingle{} that you said was bad about other libraries?}\label{md__home_denis_Documents_Faks_master_RS2_TennisAssociation_TennisAssociation_Client_node_modules6a5b0f5bc4545e9a2fe961ba376b04c1_autotoc_md15149}
Yeah, sorta. I wouldn\textquotesingle{}t use promzard for anything more complicated than a wizard that spits out prompts to set up a config file or something. Maybe there are other use cases I haven\textquotesingle{}t considered. 